{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "colorpicker",
  "title": "ColorPicker",
  "description": "A customizable color picker component with support for hex, rgb, and hsl formats, eye dropper, and preset colors.",
  "dependencies": ["lucide-react"],
  "registryDependencies": ["button", "input", "popover", "utils"],
  "files": [
    {
      "path": "registry/new-york/ui/custom/colorpicker.tsx",
      "content": "'use client';\n\nimport { Button } from '@components/button';\nimport { Droplet } from 'lucide-react';\nimport * as React from 'react';\nimport { cn } from '@/lib/utils';\nimport { Input } from '../shadcn/input';\nimport { Popover, PopoverContent, PopoverTrigger } from '../shadcn/popover';\n\n/* -----------------------------------------------------------------------------\n * Color Utilities\n * -------------------------------------------------------------------------- */\n\ntype ColorFormat = 'hex' | 'rgb' | 'hsl';\n\ninterface RGB {\n  r: number;\n  g: number;\n  b: number;\n}\n\ninterface HSL {\n  h: number;\n  s: number;\n  l: number;\n}\n\nfunction hexToRgb(hex: string): RGB | null {\n  const result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\n  return result\n    ? {\n        r: Number.parseInt(result[1], 16),\n        g: Number.parseInt(result[2], 16),\n        b: Number.parseInt(result[3], 16),\n      }\n    : null;\n}\n\nfunction rgbToHex(r: number, g: number, b: number): string {\n  return `#${[r, g, b].map((x) => x.toString(16).padStart(2, '0')).join('')}`;\n}\n\nfunction rgbToHsl(r: number, g: number, b: number): HSL {\n  const rNorm = r / 255;\n  const gNorm = g / 255;\n  const bNorm = b / 255;\n\n  const max = Math.max(rNorm, gNorm, bNorm);\n  const min = Math.min(rNorm, gNorm, bNorm);\n  let h = 0;\n  let s = 0;\n  const l = (max + min) / 2;\n\n  if (max !== min) {\n    const d = max - min;\n    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);\n\n    switch (max) {\n      case rNorm:\n        h = ((gNorm - bNorm) / d + (gNorm < bNorm ? 6 : 0)) / 6;\n        break;\n      case gNorm:\n        h = ((bNorm - rNorm) / d + 2) / 6;\n        break;\n      case bNorm:\n        h = ((rNorm - gNorm) / d + 4) / 6;\n        break;\n    }\n  }\n\n  return {\n    h: h * 360,\n    s: s * 100,\n    l: l * 100,\n  };\n}\n\nfunction hslToRgb(h: number, s: number, l: number): RGB {\n  const hNorm = h / 360;\n  const sNorm = s / 100;\n  const lNorm = l / 100;\n\n  let r: number;\n  let g: number;\n  let b: number;\n\n  if (sNorm === 0) {\n    r = g = b = lNorm;\n  } else {\n    const hue2rgb = (p: number, q: number, t: number) => {\n      let tNorm = t;\n      if (tNorm < 0) tNorm += 1;\n      if (tNorm > 1) tNorm -= 1;\n      if (tNorm < 1 / 6) return p + (q - p) * 6 * tNorm;\n      if (tNorm < 1 / 2) return q;\n      if (tNorm < 2 / 3) return p + (q - p) * (2 / 3 - tNorm) * 6;\n      return p;\n    };\n\n    const q = lNorm < 0.5 ? lNorm * (1 + sNorm) : lNorm + sNorm - lNorm * sNorm;\n    const p = 2 * lNorm - q;\n\n    r = hue2rgb(p, q, hNorm + 1 / 3);\n    g = hue2rgb(p, q, hNorm);\n    b = hue2rgb(p, q, hNorm - 1 / 3);\n  }\n\n  return {\n    r: Math.round(r * 255),\n    g: Math.round(g * 255),\n    b: Math.round(b * 255),\n  };\n}\n\nfunction parseColor(color: string): { rgb: RGB; hsl: HSL; hex: string } | null {\n  // Try hex first\n  if (color.startsWith('#')) {\n    const rgb = hexToRgb(color);\n    if (rgb) {\n      const hsl = rgbToHsl(rgb.r, rgb.g, rgb.b);\n      // Normalize hex to lowercase and ensure 6 digits\n      const normalizedHex = rgbToHex(rgb.r, rgb.g, rgb.b).toLowerCase();\n      return { rgb, hsl, hex: normalizedHex };\n    }\n  }\n\n  // Try rgb/rgba\n  const rgbMatch = color.match(/rgba?\\((\\d+),\\s*(\\d+),\\s*(\\d+)(?:,\\s*[\\d.]+)?\\)/);\n  if (rgbMatch) {\n    const r = Number.parseInt(rgbMatch[1], 10);\n    const g = Number.parseInt(rgbMatch[2], 10);\n    const b = Number.parseInt(rgbMatch[3], 10);\n    const hex = rgbToHex(r, g, b).toLowerCase();\n    const hsl = rgbToHsl(r, g, b);\n    return { rgb: { r, g, b }, hsl, hex };\n  }\n\n  // Try hsl/hsla\n  const hslMatch = color.match(/hsla?\\((\\d+),\\s*(\\d+)%,\\s*(\\d+)%(?:,\\s*[\\d.]+)?\\)/);\n  if (hslMatch) {\n    const h = Number.parseInt(hslMatch[1], 10);\n    const s = Number.parseInt(hslMatch[2], 10);\n    const l = Number.parseInt(hslMatch[3], 10);\n    const rgb = hslToRgb(h, s, l);\n    const hex = rgbToHex(rgb.r, rgb.g, rgb.b).toLowerCase();\n    return { rgb, hsl: { h, s, l }, hex };\n  }\n\n  return null;\n}\n\nfunction formatColor(color: { rgb: RGB; hsl: HSL; hex: string }, format: ColorFormat): string {\n  switch (format) {\n    case 'hex':\n      return color.hex;\n    case 'rgb':\n      return `rgb(${color.rgb.r}, ${color.rgb.g}, ${color.rgb.b})`;\n    case 'hsl':\n      return `hsl(${Math.round(color.hsl.h)}, ${Math.round(color.hsl.s)}%, ${Math.round(color.hsl.l)}%)`;\n    default:\n      return color.hex;\n  }\n}\n\n/* -----------------------------------------------------------------------------\n * Types\n * -------------------------------------------------------------------------- */\n\ninterface ColorPickerContextValue {\n  value: string;\n  setValue: (value: string) => void;\n  open: boolean;\n  setOpen: (open: boolean) => void;\n  format: ColorFormat;\n  setFormat: (format: ColorFormat) => void;\n  color: { rgb: RGB; hsl: HSL; hex: string };\n  disabled?: boolean;\n}\n\nconst ColorPickerContext = React.createContext<ColorPickerContextValue | null>(null);\n\nfunction useColorPicker() {\n  const context = React.useContext(ColorPickerContext);\n  if (!context) {\n    throw new Error('useColorPicker must be used within a ColorPicker');\n  }\n  return context;\n}\n\n/* -----------------------------------------------------------------------------\n * ColorPicker (Root)\n * -------------------------------------------------------------------------- */\n\nexport interface ColorPickerProps {\n  value?: string;\n  defaultValue?: string;\n  onValueChange?: (value: string) => void;\n  open?: boolean;\n  defaultOpen?: boolean;\n  onOpenChange?: (open: boolean) => void;\n  defaultFormat?: ColorFormat;\n  disabled?: boolean;\n  children: React.ReactNode;\n}\n\nexport function ColorPicker({\n  value: controlledValue,\n  defaultValue = '#000000',\n  onValueChange,\n  open: controlledOpen,\n  defaultOpen = false,\n  onOpenChange,\n  defaultFormat = 'hex',\n  disabled,\n  children,\n}: ColorPickerProps) {\n  const [internalValue, setInternalValue] = React.useState(defaultValue);\n  const [internalOpen, setInternalOpen] = React.useState(defaultOpen);\n  const [format, setFormat] = React.useState<ColorFormat>(defaultFormat);\n\n  const value = controlledValue ?? internalValue;\n  const open = controlledOpen ?? internalOpen;\n\n  const parsedColor = React.useMemo(() => {\n    const parsed = parseColor(value);\n    return parsed || { rgb: { r: 0, g: 0, b: 0 }, hsl: { h: 0, s: 0, l: 0 }, hex: '#000000' };\n  }, [value]);\n\n  const setValue = React.useCallback(\n    (newValue: string) => {\n      if (controlledValue === undefined) {\n        setInternalValue(newValue);\n      }\n      onValueChange?.(newValue);\n    },\n    [controlledValue, onValueChange],\n  );\n\n  const setOpen = React.useCallback(\n    (newOpen: boolean) => {\n      if (controlledOpen === undefined) {\n        setInternalOpen(newOpen);\n      }\n      onOpenChange?.(newOpen);\n    },\n    [controlledOpen, onOpenChange],\n  );\n\n  const contextValue = React.useMemo<ColorPickerContextValue>(\n    () => ({\n      value,\n      setValue,\n      open,\n      setOpen,\n      format,\n      setFormat,\n      color: parsedColor,\n      disabled,\n    }),\n    [value, setValue, open, setOpen, format, parsedColor, disabled],\n  );\n\n  return (\n    <ColorPickerContext.Provider value={contextValue}>\n      <Popover\n        open={open}\n        onOpenChange={setOpen}\n      >\n        {children}\n      </Popover>\n    </ColorPickerContext.Provider>\n  );\n}\n\n/* -----------------------------------------------------------------------------\n * ColorPickerTrigger\n * -------------------------------------------------------------------------- */\n\nexport interface ColorPickerTriggerProps extends React.ComponentProps<typeof PopoverTrigger> {}\n\nexport function ColorPickerTrigger({ className, children, ...props }: ColorPickerTriggerProps) {\n  const { disabled } = useColorPicker();\n\n  return (\n    <PopoverTrigger\n      asChild\n      disabled={disabled}\n      className={className}\n      {...props}\n    >\n      {children}\n    </PopoverTrigger>\n  );\n}\n\n/* -----------------------------------------------------------------------------\n * ColorPickerContent\n * -------------------------------------------------------------------------- */\n\nexport interface ColorPickerContentProps extends React.ComponentProps<typeof PopoverContent> {}\n\nexport function ColorPickerContent({ className, children, ...props }: ColorPickerContentProps) {\n  return (\n    <PopoverContent\n      className={cn('w-auto p-3', className)}\n      {...props}\n    >\n      {children}\n    </PopoverContent>\n  );\n}\n\n/* -----------------------------------------------------------------------------\n * ColorPickerSwatch\n * -------------------------------------------------------------------------- */\n\nexport interface ColorPickerSwatchProps extends React.ComponentProps<'div'> {}\n\nexport function ColorPickerSwatch({ className, ...props }: ColorPickerSwatchProps) {\n  const { value } = useColorPicker();\n\n  return (\n    <div\n      data-slot=\"colorpicker-swatch\"\n      className={cn('size-4 rounded border border-[var(--border)]', className)}\n      style={{ backgroundColor: value }}\n      {...props}\n    />\n  );\n}\n\n/* -----------------------------------------------------------------------------\n * ColorPickerArea\n * -------------------------------------------------------------------------- */\n\nexport interface ColorPickerAreaProps extends React.ComponentProps<'div'> {}\n\nexport function ColorPickerArea({ className, ...props }: ColorPickerAreaProps) {\n  const { color, setValue } = useColorPicker();\n  const areaRef = React.useRef<HTMLDivElement>(null);\n  const [isDragging, setIsDragging] = React.useState(false);\n\n  const handlePointerDown = React.useCallback(\n    (e: React.PointerEvent<HTMLDivElement>) => {\n      setIsDragging(true);\n      const rect = areaRef.current?.getBoundingClientRect();\n      if (!rect) return;\n\n      const x = Math.max(0, Math.min(1, (e.clientX - rect.left) / rect.width));\n      const y = Math.max(0, Math.min(1, (e.clientY - rect.top) / rect.height));\n\n      const s = x * 100;\n      const l = (1 - y) * 100;\n\n      const newRgb = hslToRgb(color.hsl.h, s, l);\n      const newHex = rgbToHex(newRgb.r, newRgb.g, newRgb.b).toLowerCase();\n      setValue(newHex);\n    },\n    [color.hsl.h, setValue],\n  );\n\n  const handlePointerMove = React.useCallback(\n    (e: PointerEvent) => {\n      if (!isDragging) return;\n      const rect = areaRef.current?.getBoundingClientRect();\n      if (!rect) return;\n\n      const x = Math.max(0, Math.min(1, (e.clientX - rect.left) / rect.width));\n      const y = Math.max(0, Math.min(1, (e.clientY - rect.top) / rect.height));\n\n      const s = x * 100;\n      const l = (1 - y) * 100;\n\n      const newRgb = hslToRgb(color.hsl.h, s, l);\n      const newHex = rgbToHex(newRgb.r, newRgb.g, newRgb.b).toLowerCase();\n      setValue(newHex);\n    },\n    [isDragging, color.hsl.h, setValue],\n  );\n\n  const handlePointerUp = React.useCallback(() => {\n    setIsDragging(false);\n  }, []);\n\n  React.useEffect(() => {\n    if (isDragging) {\n      document.addEventListener('pointermove', handlePointerMove);\n      document.addEventListener('pointerup', handlePointerUp);\n      return () => {\n        document.removeEventListener('pointermove', handlePointerMove);\n        document.removeEventListener('pointerup', handlePointerUp);\n      };\n    }\n  }, [isDragging, handlePointerMove, handlePointerUp]);\n\n  const hueColor = React.useMemo(() => {\n    const rgb = hslToRgb(color.hsl.h, 100, 50);\n    return rgbToHex(rgb.r, rgb.g, rgb.b);\n  }, [color.hsl.h]);\n\n  const position = React.useMemo(() => {\n    return {\n      x: color.hsl.s / 100,\n      y: 1 - color.hsl.l / 100,\n    };\n  }, [color.hsl.s, color.hsl.l]);\n\n  return (\n    <div\n      ref={areaRef}\n      data-slot=\"colorpicker-area\"\n      className={cn('relative h-40 w-full rounded-md border border-[var(--border)] cursor-crosshair overflow-hidden', className)}\n      onPointerDown={handlePointerDown}\n      {...props}\n    >\n      {/* Base: Saturation gradient from white (left, s=0%) to full hue (right, s=100%) */}\n      <div\n        className=\"absolute inset-0\"\n        style={{\n          background: `linear-gradient(to right, #fff 0%, ${hueColor} 100%)`,\n        }}\n      />\n      {/* Overlay: Lightness gradient from transparent (top, l=100%) to black (bottom, l=0%) */}\n      <div\n        className=\"absolute inset-0\"\n        style={{\n          background: 'linear-gradient(to bottom, rgba(0,0,0,0) 0%, rgba(0,0,0,1) 100%)',\n        }}\n      />\n      <div\n        className=\"absolute size-3 -translate-x-1/2 -translate-y-1/2 rounded-full border-2 border-white shadow-lg pointer-events-none z-10\"\n        style={{\n          left: `${position.x * 100}%`,\n          top: `${position.y * 100}%`,\n        }}\n      />\n    </div>\n  );\n}\n\n/* -----------------------------------------------------------------------------\n * ColorPickerHueSlider\n * -------------------------------------------------------------------------- */\n\nexport interface ColorPickerHueSliderProps extends React.ComponentProps<'div'> {}\n\nexport function ColorPickerHueSlider({ className, ...props }: ColorPickerHueSliderProps) {\n  const { color, setValue } = useColorPicker();\n  const sliderRef = React.useRef<HTMLDivElement>(null);\n  const [isDragging, setIsDragging] = React.useState(false);\n\n  const handlePointerDown = React.useCallback(\n    (e: React.PointerEvent<HTMLDivElement>) => {\n      setIsDragging(true);\n      const rect = sliderRef.current?.getBoundingClientRect();\n      if (!rect) return;\n\n      const x = Math.max(0, Math.min(1, (e.clientX - rect.left) / rect.width));\n      const h = x * 360;\n\n      const newRgb = hslToRgb(h, color.hsl.s, color.hsl.l);\n      const newHex = rgbToHex(newRgb.r, newRgb.g, newRgb.b).toLowerCase();\n      setValue(newHex);\n    },\n    [color.hsl.s, color.hsl.l, setValue],\n  );\n\n  const handlePointerMove = React.useCallback(\n    (e: PointerEvent) => {\n      if (!isDragging) return;\n      const rect = sliderRef.current?.getBoundingClientRect();\n      if (!rect) return;\n\n      const x = Math.max(0, Math.min(1, (e.clientX - rect.left) / rect.width));\n      const h = x * 360;\n\n      const newRgb = hslToRgb(h, color.hsl.s, color.hsl.l);\n      const newHex = rgbToHex(newRgb.r, newRgb.g, newRgb.b).toLowerCase();\n      setValue(newHex);\n    },\n    [isDragging, color.hsl.s, color.hsl.l, setValue],\n  );\n\n  const handlePointerUp = React.useCallback(() => {\n    setIsDragging(false);\n  }, []);\n\n  React.useEffect(() => {\n    if (isDragging) {\n      document.addEventListener('pointermove', handlePointerMove);\n      document.addEventListener('pointerup', handlePointerUp);\n      return () => {\n        document.removeEventListener('pointermove', handlePointerMove);\n        document.removeEventListener('pointerup', handlePointerUp);\n      };\n    }\n  }, [isDragging, handlePointerMove, handlePointerUp]);\n\n  const position = color.hsl.h / 360;\n\n  return (\n    <div\n      ref={sliderRef}\n      data-slot=\"colorpicker-hue-slider\"\n      className={cn('relative h-3 w-full rounded-md border border-[var(--border)] cursor-pointer overflow-hidden', className)}\n      onPointerDown={handlePointerDown}\n      {...props}\n    >\n      <div\n        className=\"absolute inset-0\"\n        style={{\n          background:\n            'linear-gradient(to right, #ff0000 0%, #ffff00 17%, #00ff00 33%, #00ffff 50%, #0000ff 67%, #ff00ff 83%, #ff0000 100%)',\n        }}\n      />\n      <div\n        className=\"absolute top-0 bottom-0 w-1 -translate-x-1/2 rounded-full border-2 border-white shadow-lg pointer-events-none\"\n        style={{\n          left: `${position * 100}%`,\n        }}\n      />\n    </div>\n  );\n}\n\n/* -----------------------------------------------------------------------------\n * ColorPickerAlphaSlider\n * -------------------------------------------------------------------------- */\n\nexport interface ColorPickerAlphaSliderProps extends React.ComponentProps<'div'> {}\n\nexport function ColorPickerAlphaSlider({ className, ...props }: ColorPickerAlphaSliderProps) {\n  const { color } = useColorPicker();\n  // Note: Alpha support would require rgba/hsla parsing and formatting\n  // For now, this is a placeholder that shows the color but doesn't modify alpha\n  const sliderRef = React.useRef<HTMLDivElement>(null);\n  const [isDragging, setIsDragging] = React.useState(false);\n  const [alpha, setAlpha] = React.useState(1);\n\n  const handlePointerDown = React.useCallback((e: React.PointerEvent<HTMLDivElement>) => {\n    setIsDragging(true);\n    const rect = sliderRef.current?.getBoundingClientRect();\n    if (!rect) return;\n\n    const x = Math.max(0, Math.min(1, (e.clientX - rect.left) / rect.width));\n    setAlpha(x);\n  }, []);\n\n  const handlePointerMove = React.useCallback(\n    (e: PointerEvent) => {\n      if (!isDragging) return;\n      const rect = sliderRef.current?.getBoundingClientRect();\n      if (!rect) return;\n\n      const x = Math.max(0, Math.min(1, (e.clientX - rect.left) / rect.width));\n      setAlpha(x);\n    },\n    [isDragging],\n  );\n\n  const handlePointerUp = React.useCallback(() => {\n    setIsDragging(false);\n  }, []);\n\n  React.useEffect(() => {\n    if (isDragging) {\n      document.addEventListener('pointermove', handlePointerMove);\n      document.addEventListener('pointerup', handlePointerUp);\n      return () => {\n        document.removeEventListener('pointermove', handlePointerMove);\n        document.removeEventListener('pointerup', handlePointerUp);\n      };\n    }\n  }, [isDragging, handlePointerMove, handlePointerUp]);\n\n  const position = alpha;\n\n  return (\n    <div\n      ref={sliderRef}\n      data-slot=\"colorpicker-alpha-slider\"\n      className={cn('relative h-3 w-full rounded-md border border-[var(--border)] cursor-pointer overflow-hidden', className)}\n      onPointerDown={handlePointerDown}\n      {...props}\n    >\n      <div\n        className=\"absolute inset-0 opacity-30\"\n        style={{\n          backgroundImage: 'repeating-conic-gradient(#808080 0% 25%, #fff 0% 50%)',\n          backgroundSize: '8px 8px',\n        }}\n      />\n      <div\n        className=\"absolute inset-0\"\n        style={{\n          background: `linear-gradient(to right, transparent 0%, ${color.hex} 100%)`,\n        }}\n      />\n      <div\n        className=\"absolute top-0 bottom-0 w-1 -translate-x-1/2 rounded-full border-2 border-white shadow-lg pointer-events-none\"\n        style={{\n          left: `${position * 100}%`,\n        }}\n      />\n    </div>\n  );\n}\n\n/* -----------------------------------------------------------------------------\n * ColorPickerFormatSelect\n * -------------------------------------------------------------------------- */\n\nexport interface ColorPickerFormatSelectProps extends React.ComponentProps<'select'> {}\n\nexport function ColorPickerFormatSelect({ className, ...props }: ColorPickerFormatSelectProps) {\n  const { format, setFormat } = useColorPicker();\n\n  return (\n    <select\n      data-slot=\"colorpicker-format-select\"\n      value={format}\n      onChange={(e) => setFormat(e.target.value as ColorFormat)}\n      className={cn(\n        'h-9 rounded-md border border-[var(--input)] bg-[var(--background)] px-3 py-1 text-sm focus:outline-none focus:ring-2 focus:ring-[var(--ring)]',\n        className,\n      )}\n      {...props}\n    >\n      <option value=\"hex\">HEX</option>\n      <option value=\"rgb\">RGB</option>\n      <option value=\"hsl\">HSL</option>\n    </select>\n  );\n}\n\n/* -----------------------------------------------------------------------------\n * ColorPickerInput\n * -------------------------------------------------------------------------- */\n\nexport interface ColorPickerInputProps extends Omit<React.ComponentProps<typeof Input>, 'value' | 'onChange'> {}\n\nexport function ColorPickerInput({ className, ...props }: ColorPickerInputProps) {\n  const { color, format, setValue } = useColorPicker();\n  const [inputValue, setInputValue] = React.useState(formatColor(color, format));\n\n  React.useEffect(() => {\n    setInputValue(formatColor(color, format));\n  }, [color, format]);\n\n  const handleChange = React.useCallback(\n    (e: React.ChangeEvent<HTMLInputElement>) => {\n      const newValue = e.target.value;\n      setInputValue(newValue);\n\n      const parsed = parseColor(newValue);\n      if (parsed) {\n        setValue(parsed.hex);\n      }\n    },\n    [setValue],\n  );\n\n  return (\n    <Input\n      data-slot=\"colorpicker-input\"\n      value={inputValue}\n      onChange={handleChange}\n      className={className}\n      {...props}\n    />\n  );\n}\n\n/* -----------------------------------------------------------------------------\n * ColorPickerEyeDropper\n * -------------------------------------------------------------------------- */\n\nexport interface ColorPickerEyeDropperProps extends React.ComponentProps<typeof Button> {}\n\nexport function ColorPickerEyeDropper({ className, ...props }: ColorPickerEyeDropperProps) {\n  const { setValue } = useColorPicker();\n  const [isSupported, setIsSupported] = React.useState(false);\n\n  React.useEffect(() => {\n    setIsSupported('EyeDropper' in window);\n  }, []);\n\n  const handleClick = React.useCallback(async () => {\n    if (!('EyeDropper' in window)) return;\n\n    try {\n      // @ts-expect-error - EyeDropper API is not in types\n      const eyeDropper = new window.EyeDropper();\n      const result = await eyeDropper.open();\n      if (result.sRGBHex) {\n        setValue(result.sRGBHex.toLowerCase());\n      }\n    } catch {\n      // User cancelled or error occurred\n    }\n  }, [setValue]);\n\n  if (!isSupported) {\n    return null;\n  }\n\n  return (\n    <Button\n      type=\"button\"\n      variant=\"outline\"\n      size=\"icon\"\n      onClick={handleClick}\n      className={cn('shrink-0', className)}\n      {...props}\n    >\n      <Droplet className=\"size-4\" />\n      <span className=\"sr-only\">Pick color from screen</span>\n    </Button>\n  );\n}\n",
      "type": "registry:ui"
    }
  ],
  "type": "registry:ui"
}
