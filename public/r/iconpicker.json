{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "iconpicker",
  "title": "IconPicker",
  "description": "A compound component for selecting icons from Lucide React with search, preview, and optimized rendering.",
  "dependencies": ["lucide-react"],
  "registryDependencies": ["button", "dialog", "input", "utils"],
  "files": [
    {
      "path": "registry/new-york/ui/custom/iconpicker.tsx",
      "content": "'use client';\n\nimport { FolderKanban, Search } from 'lucide-react';\nimport * as React from 'react';\nimport { cn } from '@/lib/utils';\nimport { useMounted } from '../../hooks/use-mounted';\nimport { formatProjectIconLabel, normalizeProjectIconName } from '../../lib/shadcn/utils';\nimport { Button } from '../shadcn/button';\nimport { Dialog, DialogContent, DialogDescription, DialogFooter, DialogHeader, DialogTitle, DialogTrigger } from '../shadcn/dialog';\nimport { Input } from '../shadcn/input';\n\ninterface IconPickerContextValue {\n  value: string;\n  setValue: (value: string) => void;\n  open: boolean;\n  setOpen: (open: boolean) => void;\n  previewName: string;\n  setPreviewName: (name: string) => void;\n  query: string;\n  setQuery: (query: string) => void;\n  deferredQuery: string;\n  iconList: string[];\n  columns: number;\n  color?: string;\n  disabled?: boolean;\n  scrollRef: React.RefObject<HTMLDivElement | null>;\n  searchInputRef: React.RefObject<HTMLInputElement | null>;\n  scrollTop: number;\n  setScrollTop: (top: number) => void;\n  visibleIcons: string[];\n  paddingTop: number;\n  paddingBottom: number;\n  onHoverIcon: (name: string) => void;\n  onUnhoverIcon: () => void;\n  isLoadingIcons: boolean;\n  mounted: boolean;\n  allIconNames: string[];\n}\n\nconst IconPickerContext = React.createContext<IconPickerContextValue | null>(null);\n\nfunction useIconPicker() {\n  const context = React.useContext(IconPickerContext);\n  if (!context) {\n    throw new Error('useIconPicker must be used within an IconPicker');\n  }\n  return context;\n}\n\nfunction pascalToKebab(str: string): string {\n  return str\n    .replace(/([a-z0-9])([A-Z])/g, '$1-$2')\n    .replace(/([A-Z])([A-Z][a-z])/g, '$1-$2')\n    .toLowerCase();\n}\n\nfunction kebabToPascal(str: string): string {\n  return str\n    .split('-')\n    .map((word) => word.charAt(0).toUpperCase() + word.slice(1))\n    .join('');\n}\n\nconst iconCache = new Map<string, React.ComponentType<React.SVGProps<SVGSVGElement>> | null>();\n\nconst DynamicIcon = React.memo(function DynamicIcon({\n  name,\n  fallback: Fallback,\n  className,\n  ...props\n}: {\n  name: string;\n  fallback: React.ComponentType<React.SVGProps<SVGSVGElement>>;\n  className?: string;\n} & React.SVGProps<SVGSVGElement>) {\n  const [IconComponent, setIconComponent] = React.useState<React.ComponentType<React.SVGProps<SVGSVGElement>> | null>(\n    () => iconCache.get(name) || null,\n  );\n\n  React.useEffect(() => {\n    const cached = iconCache.get(name);\n    if (cached !== undefined) {\n      setIconComponent(cached);\n      return;\n    }\n\n    let cancelled = false;\n\n    const loadIcon = async () => {\n      try {\n        const pascalName = kebabToPascal(name);\n        const iconModule = await import('lucide-react');\n\n        let Icon: React.ComponentType<React.SVGProps<SVGSVGElement>> | undefined;\n\n        const directIcon = iconModule[pascalName as keyof typeof iconModule];\n        if (directIcon) {\n          Icon = directIcon as React.ComponentType<React.SVGProps<SVGSVGElement>>;\n        }\n\n        if (!Icon) {\n          const iconNameWithSuffix = `${pascalName}Icon`;\n          const directIconWithSuffix = iconModule[iconNameWithSuffix as keyof typeof iconModule];\n          if (directIconWithSuffix) {\n            Icon = directIconWithSuffix as React.ComponentType<React.SVGProps<SVGSVGElement>>;\n          }\n        }\n\n        if (!cancelled) {\n          iconCache.set(name, Icon || null);\n          setIconComponent(Icon || null);\n        }\n      } catch {\n        if (!cancelled) {\n          iconCache.set(name, null);\n          setIconComponent(null);\n        }\n      }\n    };\n\n    loadIcon();\n\n    return () => {\n      cancelled = true;\n    };\n  }, [name]);\n\n  if (IconComponent) {\n    const Component = IconComponent;\n    return (\n      <Component\n        className={className}\n        {...props}\n      />\n    );\n  }\n\n  return (\n    <Fallback\n      className={className}\n      {...props}\n    />\n  );\n});\n\nexport interface IconPickerProps {\n  value?: string;\n  defaultValue?: string;\n  onValueChange?: (value: string) => void;\n  open?: boolean;\n  defaultOpen?: boolean;\n  onOpenChange?: (open: boolean) => void;\n  color?: string;\n  disabled?: boolean;\n  children: React.ReactNode;\n}\n\nexport function IconPicker({\n  value: controlledValue,\n  defaultValue,\n  onValueChange,\n  open: controlledOpen,\n  defaultOpen = false,\n  onOpenChange,\n  color,\n  disabled,\n  children,\n}: IconPickerProps) {\n  const [internalValue, setInternalValue] = React.useState<string>(() => normalizeProjectIconName(defaultValue) ?? 'folder-kanban');\n  const [internalOpen, setInternalOpen] = React.useState(defaultOpen);\n  const [previewName, setPreviewName] = React.useState<string>(() => normalizeProjectIconName(defaultValue) ?? 'folder-kanban');\n  const [query, setQuery] = React.useState('');\n  const [scrollTop, setScrollTop] = React.useState(0);\n  const [viewportHeight, setViewportHeight] = React.useState(0);\n  const [columns, setColumns] = React.useState(4);\n  const [allIconNames, setAllIconNames] = React.useState<string[]>([]);\n  const [isLoadingIcons, setIsLoadingIcons] = React.useState(false);\n\n  const value = controlledValue ?? internalValue;\n  const open = controlledOpen ?? internalOpen;\n  const mounted = useMounted();\n  const deferredQuery = React.useDeferredValue(query.trim().toLowerCase());\n\n  const setValue = React.useCallback(\n    (newValue: string) => {\n      if (controlledValue === undefined) {\n        setInternalValue(newValue);\n      }\n      onValueChange?.(newValue);\n    },\n    [controlledValue, onValueChange],\n  );\n\n  const setOpen = React.useCallback(\n    (newOpen: boolean) => {\n      if (controlledOpen === undefined) {\n        setInternalOpen(newOpen);\n      }\n      onOpenChange?.(newOpen);\n    },\n    [controlledOpen, onOpenChange],\n  );\n\n  const scrollRef = React.useRef<HTMLDivElement | null>(null);\n  const hoverTimerRef = React.useRef<number | null>(null);\n  const isHoveringRef = React.useRef(false);\n  const searchInputRef = React.useRef<HTMLInputElement | null>(null);\n  const scrollPositionRef = React.useRef<number>(0);\n  const iconsLoadedRef = React.useRef(false);\n  const prevOpenRef = React.useRef(open);\n\n  React.useEffect(() => {\n    if (!mounted || iconsLoadedRef.current) return;\n\n    iconsLoadedRef.current = true;\n    setIsLoadingIcons(true);\n\n    const loadIconNames = async () => {\n      try {\n        const iconModule = await import('lucide-react');\n        const names: string[] = [];\n        const moduleKeys = Object.keys(iconModule);\n\n        const skipKeys = new Set([\n          'createLucideIcon',\n          'default',\n          'icons',\n          'Icon',\n          'LucideIcon',\n          'IconNode',\n          'LucideProps',\n          'lucideReact',\n          'lucide-react',\n        ]);\n\n        const seenNames = new Set<string>();\n\n        for (const key of moduleKeys) {\n          if (skipKeys.has(key) || key.startsWith('_')) {\n            continue;\n          }\n\n          const exportValue = (iconModule as Record<string, unknown>)[key];\n\n          if (typeof exportValue === 'function' && key[0] && /[A-Z]/.test(key[0])) {\n            const kebabName = pascalToKebab(key);\n            if (!seenNames.has(kebabName)) {\n              seenNames.add(kebabName);\n              names.push(kebabName);\n            }\n          }\n        }\n\n        if (iconModule.icons && typeof iconModule.icons === 'object') {\n          const iconsExport = iconModule.icons;\n\n          if (typeof iconsExport === 'object' && iconsExport !== null) {\n            const iconsObj = iconsExport as Record<string, unknown>;\n            const iconObjKeys = Object.keys(iconsObj);\n\n            for (const key of iconObjKeys) {\n              if (key.endsWith('Icon')) {\n                continue;\n              }\n\n              if (key[0] && /[A-Z]/.test(key[0])) {\n                const kebabName = pascalToKebab(key);\n                if (!seenNames.has(kebabName)) {\n                  seenNames.add(kebabName);\n                  names.push(kebabName);\n                }\n              }\n            }\n          }\n        }\n\n        names.sort();\n        setAllIconNames(names);\n      } catch {\n        setAllIconNames([]);\n      } finally {\n        setIsLoadingIcons(false);\n      }\n    };\n\n    loadIconNames();\n  }, [mounted]);\n\n  const iconList = React.useMemo(() => {\n    if (!open) return [];\n    if (!deferredQuery) {\n      return allIconNames;\n    }\n\n    return allIconNames.filter((name) => {\n      if (name.includes(deferredQuery)) return true;\n      return formatProjectIconLabel(name).toLowerCase().includes(deferredQuery);\n    });\n  }, [allIconNames, deferredQuery, open]);\n\n  React.useEffect(() => {\n    const wasOpen = prevOpenRef.current;\n    prevOpenRef.current = open;\n\n    if (!open) return;\n\n    if (!wasOpen) {\n      const normalized = normalizeProjectIconName(value) ?? 'folder-kanban';\n      setPreviewName(normalized);\n      isHoveringRef.current = false;\n      setQuery('');\n      setScrollTop(0);\n\n      requestAnimationFrame(() => {\n        searchInputRef.current?.focus();\n        if (scrollRef.current) {\n          scrollRef.current.scrollTop = 0;\n        }\n      });\n\n      setViewportHeight(Math.max(320, Math.floor(window.innerHeight * 0.55)));\n    }\n  }, [open, value]);\n\n  React.useEffect(() => {\n    if (!open || isHoveringRef.current) return;\n    const normalized = normalizeProjectIconName(value) ?? 'folder-kanban';\n    setPreviewName(normalized);\n  }, [value, open]);\n\n  React.useEffect(() => {\n    if (!open || !scrollRef.current) return;\n\n    if (scrollPositionRef.current > 0) {\n      requestAnimationFrame(() => {\n        if (scrollRef.current) {\n          scrollRef.current.scrollTop = scrollPositionRef.current;\n        }\n      });\n    }\n  }, [open]);\n\n  React.useEffect(() => {\n    if (!open) return;\n\n    const updateColumns = () => {\n      const width = window.innerWidth;\n      if (width >= 768) {\n        setColumns(4);\n      } else if (width >= 640) {\n        setColumns(3);\n      } else {\n        setColumns(2);\n      }\n    };\n\n    updateColumns();\n    window.addEventListener('resize', updateColumns);\n    return () => window.removeEventListener('resize', updateColumns);\n  }, [open]);\n\n  React.useEffect(() => {\n    if (!open) return;\n\n    const el = scrollRef.current;\n    if (!el) return;\n\n    const measure = () => {\n      const next = el.clientHeight;\n      if (next > 0) {\n        setViewportHeight(next);\n      }\n    };\n\n    requestAnimationFrame(() => {\n      measure();\n      requestAnimationFrame(measure);\n    });\n\n    const observer = new ResizeObserver(measure);\n    observer.observe(el);\n    return () => observer.disconnect();\n  }, [open]);\n\n  const onHoverIcon = React.useCallback((name: string) => {\n    isHoveringRef.current = true;\n    if (hoverTimerRef.current) {\n      window.clearTimeout(hoverTimerRef.current);\n    }\n    hoverTimerRef.current = window.setTimeout(() => {\n      setPreviewName(name);\n    }, 75);\n  }, []);\n\n  const onUnhoverIcon = React.useCallback(() => {\n    isHoveringRef.current = false;\n    if (hoverTimerRef.current) {\n      window.clearTimeout(hoverTimerRef.current);\n    }\n    const normalized = normalizeProjectIconName(value) ?? 'folder-kanban';\n    hoverTimerRef.current = window.setTimeout(() => {\n      setPreviewName(normalized);\n    }, 75);\n  }, [value]);\n\n  React.useEffect(() => {\n    return () => {\n      if (hoverTimerRef.current) {\n        window.clearTimeout(hoverTimerRef.current);\n      }\n    };\n  }, []);\n\n  const rowHeight = 48;\n  const totalRows = Math.ceil(iconList.length / columns);\n  const startRow = Math.max(0, Math.floor(scrollTop / rowHeight) - 4);\n  const endRow = Math.min(totalRows, Math.ceil((scrollTop + viewportHeight) / rowHeight) + 4);\n  const startIndex = startRow * columns;\n  const endIndex = Math.min(iconList.length, endRow * columns);\n  const visibleIcons = iconList.slice(startIndex, endIndex);\n  const paddingTop = startRow * rowHeight;\n  const paddingBottom = Math.max(0, (totalRows - endRow) * rowHeight);\n\n  const contextValue = React.useMemo<IconPickerContextValue>(\n    () => ({\n      value,\n      setValue,\n      open,\n      setOpen,\n      previewName,\n      setPreviewName,\n      query,\n      setQuery,\n      deferredQuery,\n      iconList,\n      columns,\n      color,\n      disabled,\n      scrollRef,\n      searchInputRef,\n      scrollTop,\n      setScrollTop,\n      visibleIcons,\n      paddingTop,\n      paddingBottom,\n      onHoverIcon,\n      onUnhoverIcon,\n      isLoadingIcons,\n      mounted,\n      allIconNames,\n    }),\n    [\n      value,\n      setValue,\n      open,\n      setOpen,\n      previewName,\n      query,\n      deferredQuery,\n      iconList,\n      columns,\n      color,\n      disabled,\n      scrollTop,\n      visibleIcons,\n      paddingTop,\n      paddingBottom,\n      onHoverIcon,\n      onUnhoverIcon,\n      isLoadingIcons,\n      mounted,\n      allIconNames,\n    ],\n  );\n\n  return (\n    <IconPickerContext.Provider value={contextValue}>\n      <Dialog\n        open={open}\n        onOpenChange={setOpen}\n      >\n        {children}\n      </Dialog>\n    </IconPickerContext.Provider>\n  );\n}\n\nexport interface IconPickerTriggerProps extends React.ComponentProps<typeof DialogTrigger> {}\n\nexport function IconPickerTrigger({ className, children, ...props }: IconPickerTriggerProps) {\n  const { disabled } = useIconPicker();\n\n  return (\n    <DialogTrigger\n      asChild\n      disabled={disabled}\n      className={className}\n      {...props}\n    >\n      {children}\n    </DialogTrigger>\n  );\n}\n\nexport interface IconPickerContentProps extends React.ComponentProps<typeof DialogContent> {\n  title?: string;\n  description?: string;\n}\n\nexport function IconPickerContent({\n  className,\n  title = 'Select Icon',\n  description = 'Choose any icon from Lucide.',\n  ...props\n}: IconPickerContentProps) {\n  const {\n    value,\n    setValue,\n    setOpen,\n    previewName,\n    query,\n    setQuery,\n    deferredQuery,\n    iconList,\n    columns,\n    color,\n    scrollRef,\n    searchInputRef,\n    scrollTop: _scrollTop,\n    setScrollTop,\n    visibleIcons,\n    paddingTop,\n    paddingBottom,\n    onHoverIcon,\n    onUnhoverIcon,\n    isLoadingIcons,\n    mounted,\n    allIconNames,\n  } = useIconPicker();\n\n  const scrollPositionRef = React.useRef<number>(0);\n\n  React.useEffect(() => {\n    if (!scrollRef.current) return;\n\n    if (scrollPositionRef.current > 0) {\n      requestAnimationFrame(() => {\n        if (scrollRef.current) {\n          scrollRef.current.scrollTop = scrollPositionRef.current;\n        }\n      });\n    }\n  }, [scrollRef]);\n\n  const draft = React.useMemo(() => normalizeProjectIconName(value) ?? 'folder-kanban', [value]);\n\n  return (\n    <DialogContent\n      className={cn('sm:max-w-3xl', className)}\n      {...props}\n    >\n      <DialogHeader>\n        <DialogTitle>{title}</DialogTitle>\n        <DialogDescription>{description}</DialogDescription>\n      </DialogHeader>\n\n      <div className=\"flex items-start gap-4\">\n        <div className=\"shrink-0 w-48\">\n          <div\n            className=\"h-16 w-16 rounded-lg flex items-center justify-center border border-[var(--border)]\"\n            style={{ backgroundColor: color || 'var(--muted)' }}\n          >\n            <DynamicIcon\n              key={previewName}\n              name={previewName}\n              fallback={FolderKanban}\n              className={cn('h-8 w-8', color ? 'text-white' : 'text-[var(--foreground)]')}\n            />\n          </div>\n          <div className=\"mt-2 h-5 text-sm font-medium truncate\">{formatProjectIconLabel(previewName)}</div>\n          <div className=\"h-4 text-xs text-[var(--muted-foreground)] truncate\">{previewName}</div>\n        </div>\n\n        <div className=\"flex-1\">\n          <div className=\"mb-2\">\n            <div className=\"relative\">\n              <Search className=\"absolute left-3 top-1/2 -translate-y-1/2 h-4 w-4 text-[var(--muted-foreground)]\" />\n              <Input\n                ref={searchInputRef}\n                value={query}\n                onChange={(e) => {\n                  setQuery(e.target.value);\n                  setScrollTop(0);\n                  if (scrollRef.current) {\n                    scrollRef.current.scrollTop = 0;\n                  }\n                }}\n                placeholder=\"Search icons...\"\n                className=\"pl-9\"\n              />\n            </div>\n          </div>\n          <div\n            ref={scrollRef}\n            className=\"h-[55vh] overflow-auto pr-2\"\n            onScroll={(e) => {\n              const newScrollTop = (e.currentTarget as HTMLDivElement).scrollTop;\n              setScrollTop(newScrollTop);\n              scrollPositionRef.current = newScrollTop;\n            }}\n          >\n            {!mounted || isLoadingIcons ? (\n              <div className=\"flex items-center justify-center h-full text-[var(--muted-foreground)]\">\n                <div className=\"text-center\">\n                  <div className=\"animate-pulse mb-2\">Loading icons...</div>\n                  <div className=\"text-sm\">Please wait while we load all available icons</div>\n                </div>\n              </div>\n            ) : allIconNames.length === 0 && !isLoadingIcons ? (\n              <div className=\"flex items-center justify-center h-full text-[var(--muted-foreground)]\">\n                <div className=\"text-center\">\n                  <div className=\"mb-2\">No icons available</div>\n                  <div className=\"text-sm\">Failed to load icons from lucide-react. Check console for errors.</div>\n                </div>\n              </div>\n            ) : iconList.length === 0 && deferredQuery ? (\n              <div className=\"flex items-center justify-center h-full text-[var(--muted-foreground)]\">\n                <div className=\"text-center\">\n                  <div className=\"mb-2\">No icons found</div>\n                  <div className=\"text-sm\">Try adjusting your search</div>\n                </div>\n              </div>\n            ) : (\n              <div style={{ paddingTop, paddingBottom }}>\n                <div\n                  className={cn(\n                    'grid gap-2',\n                    columns === 2 && 'grid-cols-2',\n                    columns === 3 && 'grid-cols-3',\n                    columns === 4 && 'grid-cols-4',\n                  )}\n                >\n                  {visibleIcons.map((name) => {\n                    const isSelected = name === draft;\n\n                    return (\n                      <button\n                        key={name}\n                        type=\"button\"\n                        onMouseEnter={() => onHoverIcon(name)}\n                        onMouseLeave={onUnhoverIcon}\n                        onClick={() => {\n                          if (scrollRef.current) {\n                            scrollPositionRef.current = scrollRef.current.scrollTop;\n                          }\n                          setValue(name);\n                        }}\n                        className={cn(\n                          'h-10 rounded-md border border-[var(--border)] px-2 text-left text-sm flex items-center gap-2 transition-colors',\n                          'hover:bg-[var(--accent)]',\n                          isSelected && 'ring-2 ring-[var(--ring)] ring-offset-2 ring-offset-[var(--background)]',\n                        )}\n                      >\n                        <span className=\"inline-flex h-6 w-6 items-center justify-center rounded bg-[var(--muted)] shrink-0\">\n                          <DynamicIcon\n                            key={name}\n                            name={name}\n                            fallback={FolderKanban}\n                            className=\"h-4 w-4 text-[var(--foreground)]\"\n                          />\n                        </span>\n                        <span className=\"truncate flex-1\">{formatProjectIconLabel(name)}</span>\n                      </button>\n                    );\n                  })}\n                </div>\n              </div>\n            )}\n          </div>\n        </div>\n      </div>\n\n      <DialogFooter>\n        <Button\n          type=\"button\"\n          variant=\"outline\"\n          onClick={() => setOpen(false)}\n        >\n          Cancel\n        </Button>\n        <Button\n          type=\"button\"\n          onClick={() => {\n            setValue(draft);\n            setOpen(false);\n          }}\n        >\n          Select\n        </Button>\n      </DialogFooter>\n    </DialogContent>\n  );\n}\n\nexport interface IconPickerPreviewProps extends React.ComponentProps<'div'> {\n  size?: number;\n}\n\nexport function IconPickerPreview({ className, size = 24, ...props }: IconPickerPreviewProps) {\n  const { value, color } = useIconPicker();\n  const iconName = React.useMemo(() => normalizeProjectIconName(value) ?? 'folder-kanban', [value]);\n\n  return (\n    <div\n      className={cn('inline-flex items-center justify-center', className)}\n      {...props}\n    >\n      <DynamicIcon\n        name={iconName}\n        fallback={FolderKanban}\n        width={size}\n        height={size}\n        className={cn(color ? 'text-white' : 'text-[var(--foreground)]')}\n      />\n    </div>\n  );\n}\n",
      "type": "registry:ui"
    }
  ],
  "type": "registry:ui"
}
