{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "iconpicker",
  "title": "IconPicker",
  "description": "A compound component for selecting icons from Lucide React with search, preview, and optimized rendering.",
  "dependencies": [
    "lucide-react"
  ],
  "registryDependencies": [
    "button",
    "dialog",
    "input",
    "utils"
  ],
  "files": [
    {
      "path": "registry/new-york/ui/custom/iconpicker.tsx",
      "content": "'use client';\r\n\r\nimport { FolderKanban, Search } from 'lucide-react';\r\nimport * as React from 'react';\r\nimport { cn } from '@/lib/utils';\r\nimport { useMounted } from '../../hooks/use-mounted';\r\nimport { formatProjectIconLabel, normalizeProjectIconName } from '../../lib/shadcn/utils';\r\nimport { Button } from '../shadcn/button';\r\nimport { Dialog, DialogContent, DialogDescription, DialogFooter, DialogHeader, DialogTitle, DialogTrigger } from '../shadcn/dialog';\r\nimport { Input } from '../shadcn/input';\r\n\r\ninterface IconPickerContextValue {\r\n  value: string;\r\n  setValue: (value: string) => void;\r\n  open: boolean;\r\n  setOpen: (open: boolean) => void;\r\n  previewName: string;\r\n  setPreviewName: (name: string) => void;\r\n  query: string;\r\n  setQuery: (query: string) => void;\r\n  deferredQuery: string;\r\n  iconList: string[];\r\n  columns: number;\r\n  color?: string;\r\n  disabled?: boolean;\r\n  scrollRef: React.RefObject<HTMLDivElement | null>;\r\n  searchInputRef: React.RefObject<HTMLInputElement | null>;\r\n  scrollTop: number;\r\n  setScrollTop: (top: number) => void;\r\n  visibleIcons: string[];\r\n  paddingTop: number;\r\n  paddingBottom: number;\r\n  onHoverIcon: (name: string) => void;\r\n  onUnhoverIcon: () => void;\r\n  isLoadingIcons: boolean;\r\n  mounted: boolean;\r\n  allIconNames: string[];\r\n}\r\n\r\nconst IconPickerContext = React.createContext<IconPickerContextValue | null>(null);\r\n\r\nfunction useIconPicker() {\r\n  const context = React.useContext(IconPickerContext);\r\n  if (!context) {\r\n    throw new Error('useIconPicker must be used within an IconPicker');\r\n  }\r\n  return context;\r\n}\r\n\r\nfunction pascalToKebab(str: string): string {\r\n  return str\r\n    .replace(/([a-z0-9])([A-Z])/g, '$1-$2')\r\n    .replace(/([A-Z])([A-Z][a-z])/g, '$1-$2')\r\n    .toLowerCase();\r\n}\r\n\r\nfunction kebabToPascal(str: string): string {\r\n  return str\r\n    .split('-')\r\n    .map((word) => word.charAt(0).toUpperCase() + word.slice(1))\r\n    .join('');\r\n}\r\n\r\nconst iconCache = new Map<string, React.ComponentType<React.SVGProps<SVGSVGElement>> | null>();\r\n\r\nconst DynamicIcon = React.memo(function DynamicIcon({\r\n  name,\r\n  fallback: Fallback,\r\n  className,\r\n  ...props\r\n}: {\r\n  name: string;\r\n  fallback: React.ComponentType<React.SVGProps<SVGSVGElement>>;\r\n  className?: string;\r\n} & React.SVGProps<SVGSVGElement>) {\r\n  const [IconComponent, setIconComponent] = React.useState<React.ComponentType<React.SVGProps<SVGSVGElement>> | null>(\r\n    () => iconCache.get(name) || null,\r\n  );\r\n\r\n  React.useEffect(() => {\r\n    const cached = iconCache.get(name);\r\n    if (cached !== undefined) {\r\n      setIconComponent(cached);\r\n      return;\r\n    }\r\n\r\n    let cancelled = false;\r\n\r\n    const loadIcon = async () => {\r\n      try {\r\n        const pascalName = kebabToPascal(name);\r\n        const iconModule = await import('lucide-react');\r\n\r\n        let Icon: React.ComponentType<React.SVGProps<SVGSVGElement>> | undefined;\r\n\r\n        const directIcon = iconModule[pascalName as keyof typeof iconModule];\r\n        if (directIcon) {\r\n          Icon = directIcon as React.ComponentType<React.SVGProps<SVGSVGElement>>;\r\n        }\r\n\r\n        if (!Icon) {\r\n          const iconNameWithSuffix = `${pascalName}Icon`;\r\n          const directIconWithSuffix = iconModule[iconNameWithSuffix as keyof typeof iconModule];\r\n          if (directIconWithSuffix) {\r\n            Icon = directIconWithSuffix as React.ComponentType<React.SVGProps<SVGSVGElement>>;\r\n          }\r\n        }\r\n\r\n        if (!cancelled) {\r\n          iconCache.set(name, Icon || null);\r\n          setIconComponent(Icon || null);\r\n        }\r\n      } catch {\r\n        if (!cancelled) {\r\n          iconCache.set(name, null);\r\n          setIconComponent(null);\r\n        }\r\n      }\r\n    };\r\n\r\n    loadIcon();\r\n\r\n    return () => {\r\n      cancelled = true;\r\n    };\r\n  }, [name]);\r\n\r\n  if (IconComponent) {\r\n    const Component = IconComponent;\r\n    return (\r\n      <Component\r\n        className={className}\r\n        {...props}\r\n      />\r\n    );\r\n  }\r\n\r\n  return (\r\n    <Fallback\r\n      className={className}\r\n      {...props}\r\n    />\r\n  );\r\n});\r\n\r\nexport interface IconPickerProps {\r\n  value?: string;\r\n  defaultValue?: string;\r\n  onValueChange?: (value: string) => void;\r\n  open?: boolean;\r\n  defaultOpen?: boolean;\r\n  onOpenChange?: (open: boolean) => void;\r\n  color?: string;\r\n  disabled?: boolean;\r\n  children: React.ReactNode;\r\n}\r\n\r\nexport function IconPicker({\r\n  value: controlledValue,\r\n  defaultValue,\r\n  onValueChange,\r\n  open: controlledOpen,\r\n  defaultOpen = false,\r\n  onOpenChange,\r\n  color,\r\n  disabled,\r\n  children,\r\n}: IconPickerProps) {\r\n  const [internalValue, setInternalValue] = React.useState<string>(() => normalizeProjectIconName(defaultValue) ?? 'folder-kanban');\r\n  const [internalOpen, setInternalOpen] = React.useState(defaultOpen);\r\n  const [previewName, setPreviewName] = React.useState<string>(() => normalizeProjectIconName(defaultValue) ?? 'folder-kanban');\r\n  const [query, setQuery] = React.useState('');\r\n  const [scrollTop, setScrollTop] = React.useState(0);\r\n  const [viewportHeight, setViewportHeight] = React.useState(0);\r\n  const [columns, setColumns] = React.useState(4);\r\n  const [allIconNames, setAllIconNames] = React.useState<string[]>([]);\r\n  const [isLoadingIcons, setIsLoadingIcons] = React.useState(false);\r\n\r\n  const value = controlledValue ?? internalValue;\r\n  const open = controlledOpen ?? internalOpen;\r\n  const mounted = useMounted();\r\n  const deferredQuery = React.useDeferredValue(query.trim().toLowerCase());\r\n\r\n  const setValue = React.useCallback(\r\n    (newValue: string) => {\r\n      if (controlledValue === undefined) {\r\n        setInternalValue(newValue);\r\n      }\r\n      onValueChange?.(newValue);\r\n    },\r\n    [controlledValue, onValueChange],\r\n  );\r\n\r\n  const setOpen = React.useCallback(\r\n    (newOpen: boolean) => {\r\n      if (controlledOpen === undefined) {\r\n        setInternalOpen(newOpen);\r\n      }\r\n      onOpenChange?.(newOpen);\r\n    },\r\n    [controlledOpen, onOpenChange],\r\n  );\r\n\r\n  const scrollRef = React.useRef<HTMLDivElement | null>(null);\r\n  const hoverTimerRef = React.useRef<number | null>(null);\r\n  const isHoveringRef = React.useRef(false);\r\n  const searchInputRef = React.useRef<HTMLInputElement | null>(null);\r\n  const scrollPositionRef = React.useRef<number>(0);\r\n  const iconsLoadedRef = React.useRef(false);\r\n  const prevOpenRef = React.useRef(open);\r\n\r\n  React.useEffect(() => {\r\n    if (!mounted || iconsLoadedRef.current) return;\r\n\r\n    iconsLoadedRef.current = true;\r\n    setIsLoadingIcons(true);\r\n\r\n    const loadIconNames = async () => {\r\n      try {\r\n        const iconModule = await import('lucide-react');\r\n        const names: string[] = [];\r\n        const moduleKeys = Object.keys(iconModule);\r\n\r\n        const skipKeys = new Set([\r\n          'createLucideIcon',\r\n          'default',\r\n          'icons',\r\n          'Icon',\r\n          'LucideIcon',\r\n          'IconNode',\r\n          'LucideProps',\r\n          'lucideReact',\r\n          'lucide-react',\r\n        ]);\r\n\r\n        const seenNames = new Set<string>();\r\n\r\n        for (const key of moduleKeys) {\r\n          if (skipKeys.has(key) || key.startsWith('_')) {\r\n            continue;\r\n          }\r\n\r\n          const exportValue = (iconModule as Record<string, unknown>)[key];\r\n\r\n          if (typeof exportValue === 'function' && key[0] && /[A-Z]/.test(key[0])) {\r\n            const kebabName = pascalToKebab(key);\r\n            if (!seenNames.has(kebabName)) {\r\n              seenNames.add(kebabName);\r\n              names.push(kebabName);\r\n            }\r\n          }\r\n        }\r\n\r\n        if (iconModule.icons && typeof iconModule.icons === 'object') {\r\n          const iconsExport = iconModule.icons;\r\n\r\n          if (typeof iconsExport === 'object' && iconsExport !== null) {\r\n            const iconsObj = iconsExport as Record<string, unknown>;\r\n            const iconObjKeys = Object.keys(iconsObj);\r\n\r\n            for (const key of iconObjKeys) {\r\n              if (key.endsWith('Icon')) {\r\n                continue;\r\n              }\r\n\r\n              if (key[0] && /[A-Z]/.test(key[0])) {\r\n                const kebabName = pascalToKebab(key);\r\n                if (!seenNames.has(kebabName)) {\r\n                  seenNames.add(kebabName);\r\n                  names.push(kebabName);\r\n                }\r\n              }\r\n            }\r\n          }\r\n        }\r\n\r\n        names.sort();\r\n        setAllIconNames(names);\r\n      } catch {\r\n        setAllIconNames([]);\r\n      } finally {\r\n        setIsLoadingIcons(false);\r\n      }\r\n    };\r\n\r\n    loadIconNames();\r\n  }, [mounted]);\r\n\r\n  const iconList = React.useMemo(() => {\r\n    if (!open) return [];\r\n    if (!deferredQuery) {\r\n      return allIconNames;\r\n    }\r\n\r\n    return allIconNames.filter((name) => {\r\n      if (name.includes(deferredQuery)) return true;\r\n      return formatProjectIconLabel(name).toLowerCase().includes(deferredQuery);\r\n    });\r\n  }, [allIconNames, deferredQuery, open]);\r\n\r\n  React.useEffect(() => {\r\n    const wasOpen = prevOpenRef.current;\r\n    prevOpenRef.current = open;\r\n\r\n    if (!open) return;\r\n\r\n    if (!wasOpen) {\r\n      const normalized = normalizeProjectIconName(value) ?? 'folder-kanban';\r\n      setPreviewName(normalized);\r\n      isHoveringRef.current = false;\r\n      setQuery('');\r\n      setScrollTop(0);\r\n\r\n      requestAnimationFrame(() => {\r\n        searchInputRef.current?.focus();\r\n        if (scrollRef.current) {\r\n          scrollRef.current.scrollTop = 0;\r\n        }\r\n      });\r\n\r\n      setViewportHeight(Math.max(320, Math.floor(window.innerHeight * 0.55)));\r\n    }\r\n  }, [open, value]);\r\n\r\n  React.useEffect(() => {\r\n    if (!open || isHoveringRef.current) return;\r\n    const normalized = normalizeProjectIconName(value) ?? 'folder-kanban';\r\n    setPreviewName(normalized);\r\n  }, [value, open]);\r\n\r\n  React.useEffect(() => {\r\n    if (!open || !scrollRef.current) return;\r\n\r\n    if (scrollPositionRef.current > 0) {\r\n      requestAnimationFrame(() => {\r\n        if (scrollRef.current) {\r\n          scrollRef.current.scrollTop = scrollPositionRef.current;\r\n        }\r\n      });\r\n    }\r\n  }, [open]);\r\n\r\n  React.useEffect(() => {\r\n    if (!open) return;\r\n\r\n    const updateColumns = () => {\r\n      const width = window.innerWidth;\r\n      if (width >= 768) {\r\n        setColumns(4);\r\n      } else if (width >= 640) {\r\n        setColumns(3);\r\n      } else {\r\n        setColumns(2);\r\n      }\r\n    };\r\n\r\n    updateColumns();\r\n    window.addEventListener('resize', updateColumns);\r\n    return () => window.removeEventListener('resize', updateColumns);\r\n  }, [open]);\r\n\r\n  React.useEffect(() => {\r\n    if (!open) return;\r\n\r\n    const el = scrollRef.current;\r\n    if (!el) return;\r\n\r\n    const measure = () => {\r\n      const next = el.clientHeight;\r\n      if (next > 0) {\r\n        setViewportHeight(next);\r\n      }\r\n    };\r\n\r\n    requestAnimationFrame(() => {\r\n      measure();\r\n      requestAnimationFrame(measure);\r\n    });\r\n\r\n    const observer = new ResizeObserver(measure);\r\n    observer.observe(el);\r\n    return () => observer.disconnect();\r\n  }, [open]);\r\n\r\n  const onHoverIcon = React.useCallback((name: string) => {\r\n    isHoveringRef.current = true;\r\n    if (hoverTimerRef.current) {\r\n      window.clearTimeout(hoverTimerRef.current);\r\n    }\r\n    hoverTimerRef.current = window.setTimeout(() => {\r\n      setPreviewName(name);\r\n    }, 75);\r\n  }, []);\r\n\r\n  const onUnhoverIcon = React.useCallback(() => {\r\n    isHoveringRef.current = false;\r\n    if (hoverTimerRef.current) {\r\n      window.clearTimeout(hoverTimerRef.current);\r\n    }\r\n    const normalized = normalizeProjectIconName(value) ?? 'folder-kanban';\r\n    hoverTimerRef.current = window.setTimeout(() => {\r\n      setPreviewName(normalized);\r\n    }, 75);\r\n  }, [value]);\r\n\r\n  React.useEffect(() => {\r\n    return () => {\r\n      if (hoverTimerRef.current) {\r\n        window.clearTimeout(hoverTimerRef.current);\r\n      }\r\n    };\r\n  }, []);\r\n\r\n  const rowHeight = 48;\r\n  const totalRows = Math.ceil(iconList.length / columns);\r\n  const startRow = Math.max(0, Math.floor(scrollTop / rowHeight) - 4);\r\n  const endRow = Math.min(totalRows, Math.ceil((scrollTop + viewportHeight) / rowHeight) + 4);\r\n  const startIndex = startRow * columns;\r\n  const endIndex = Math.min(iconList.length, endRow * columns);\r\n  const visibleIcons = iconList.slice(startIndex, endIndex);\r\n  const paddingTop = startRow * rowHeight;\r\n  const paddingBottom = Math.max(0, (totalRows - endRow) * rowHeight);\r\n\r\n  const contextValue = React.useMemo<IconPickerContextValue>(\r\n    () => ({\r\n      value,\r\n      setValue,\r\n      open,\r\n      setOpen,\r\n      previewName,\r\n      setPreviewName,\r\n      query,\r\n      setQuery,\r\n      deferredQuery,\r\n      iconList,\r\n      columns,\r\n      color,\r\n      disabled,\r\n      scrollRef,\r\n      searchInputRef,\r\n      scrollTop,\r\n      setScrollTop,\r\n      visibleIcons,\r\n      paddingTop,\r\n      paddingBottom,\r\n      onHoverIcon,\r\n      onUnhoverIcon,\r\n      isLoadingIcons,\r\n      mounted,\r\n      allIconNames,\r\n    }),\r\n    [\r\n      value,\r\n      setValue,\r\n      open,\r\n      setOpen,\r\n      previewName,\r\n      query,\r\n      deferredQuery,\r\n      iconList,\r\n      columns,\r\n      color,\r\n      disabled,\r\n      scrollTop,\r\n      visibleIcons,\r\n      paddingTop,\r\n      paddingBottom,\r\n      onHoverIcon,\r\n      onUnhoverIcon,\r\n      isLoadingIcons,\r\n      mounted,\r\n      allIconNames,\r\n    ],\r\n  );\r\n\r\n  return (\r\n    <IconPickerContext.Provider value={contextValue}>\r\n      <Dialog\r\n        open={open}\r\n        onOpenChange={setOpen}\r\n      >\r\n        {children}\r\n      </Dialog>\r\n    </IconPickerContext.Provider>\r\n  );\r\n}\r\n\r\nexport interface IconPickerTriggerProps extends React.ComponentProps<typeof DialogTrigger> {}\r\n\r\nexport function IconPickerTrigger({ className, children, ...props }: IconPickerTriggerProps) {\r\n  const { disabled } = useIconPicker();\r\n\r\n  return (\r\n    <DialogTrigger\r\n      asChild\r\n      disabled={disabled}\r\n      className={className}\r\n      {...props}\r\n    >\r\n      {children}\r\n    </DialogTrigger>\r\n  );\r\n}\r\n\r\nexport interface IconPickerContentProps extends React.ComponentProps<typeof DialogContent> {\r\n  title?: string;\r\n  description?: string;\r\n}\r\n\r\nexport function IconPickerContent({\r\n  className,\r\n  title = 'Select Icon',\r\n  description = 'Choose any icon from Lucide.',\r\n  ...props\r\n}: IconPickerContentProps) {\r\n  const {\r\n    value,\r\n    setValue,\r\n    setOpen,\r\n    previewName,\r\n    query,\r\n    setQuery,\r\n    deferredQuery,\r\n    iconList,\r\n    columns,\r\n    color,\r\n    scrollRef,\r\n    searchInputRef,\r\n    scrollTop: _scrollTop,\r\n    setScrollTop,\r\n    visibleIcons,\r\n    paddingTop,\r\n    paddingBottom,\r\n    onHoverIcon,\r\n    onUnhoverIcon,\r\n    isLoadingIcons,\r\n    mounted,\r\n    allIconNames,\r\n  } = useIconPicker();\r\n\r\n  const scrollPositionRef = React.useRef<number>(0);\r\n\r\n  React.useEffect(() => {\r\n    if (!scrollRef.current) return;\r\n\r\n    if (scrollPositionRef.current > 0) {\r\n      requestAnimationFrame(() => {\r\n        if (scrollRef.current) {\r\n          scrollRef.current.scrollTop = scrollPositionRef.current;\r\n        }\r\n      });\r\n    }\r\n  }, [scrollRef]);\r\n\r\n  const draft = React.useMemo(() => normalizeProjectIconName(value) ?? 'folder-kanban', [value]);\r\n\r\n  return (\r\n    <DialogContent\r\n      className={cn('sm:max-w-3xl', className)}\r\n      {...props}\r\n    >\r\n      <DialogHeader>\r\n        <DialogTitle>{title}</DialogTitle>\r\n        <DialogDescription>{description}</DialogDescription>\r\n      </DialogHeader>\r\n\r\n      <div className=\"flex items-start gap-4\">\r\n        <div className=\"shrink-0 w-48\">\r\n          <div\r\n            className=\"h-16 w-16 rounded-lg flex items-center justify-center border border-[var(--border)]\"\r\n            style={{ backgroundColor: color || 'var(--muted)' }}\r\n          >\r\n            <DynamicIcon\r\n              key={previewName}\r\n              name={previewName}\r\n              fallback={FolderKanban}\r\n              className={cn('h-8 w-8', color ? 'text-white' : 'text-[var(--foreground)]')}\r\n            />\r\n          </div>\r\n          <div className=\"mt-2 h-5 text-sm font-medium truncate\">{formatProjectIconLabel(previewName)}</div>\r\n          <div className=\"h-4 text-xs text-[var(--muted-foreground)] truncate\">{previewName}</div>\r\n        </div>\r\n\r\n        <div className=\"flex-1\">\r\n          <div className=\"mb-2\">\r\n            <div className=\"relative\">\r\n              <Search className=\"absolute left-3 top-1/2 -translate-y-1/2 h-4 w-4 text-[var(--muted-foreground)]\" />\r\n              <Input\r\n                ref={searchInputRef}\r\n                value={query}\r\n                onChange={(e) => {\r\n                  setQuery(e.target.value);\r\n                  setScrollTop(0);\r\n                  if (scrollRef.current) {\r\n                    scrollRef.current.scrollTop = 0;\r\n                  }\r\n                }}\r\n                placeholder=\"Search icons...\"\r\n                className=\"pl-9\"\r\n              />\r\n            </div>\r\n          </div>\r\n          <div\r\n            ref={scrollRef}\r\n            className=\"h-[55vh] overflow-auto pr-2\"\r\n            onScroll={(e) => {\r\n              const newScrollTop = (e.currentTarget as HTMLDivElement).scrollTop;\r\n              setScrollTop(newScrollTop);\r\n              scrollPositionRef.current = newScrollTop;\r\n            }}\r\n          >\r\n            {!mounted || isLoadingIcons ? (\r\n              <div className=\"flex items-center justify-center h-full text-[var(--muted-foreground)]\">\r\n                <div className=\"text-center\">\r\n                  <div className=\"animate-pulse mb-2\">Loading icons...</div>\r\n                  <div className=\"text-sm\">Please wait while we load all available icons</div>\r\n                </div>\r\n              </div>\r\n            ) : allIconNames.length === 0 && !isLoadingIcons ? (\r\n              <div className=\"flex items-center justify-center h-full text-[var(--muted-foreground)]\">\r\n                <div className=\"text-center\">\r\n                  <div className=\"mb-2\">No icons available</div>\r\n                  <div className=\"text-sm\">Failed to load icons from lucide-react. Check console for errors.</div>\r\n                </div>\r\n              </div>\r\n            ) : iconList.length === 0 && deferredQuery ? (\r\n              <div className=\"flex items-center justify-center h-full text-[var(--muted-foreground)]\">\r\n                <div className=\"text-center\">\r\n                  <div className=\"mb-2\">No icons found</div>\r\n                  <div className=\"text-sm\">Try adjusting your search</div>\r\n                </div>\r\n              </div>\r\n            ) : (\r\n              <div style={{ paddingTop, paddingBottom }}>\r\n                <div\r\n                  className={cn(\r\n                    'grid gap-2',\r\n                    columns === 2 && 'grid-cols-2',\r\n                    columns === 3 && 'grid-cols-3',\r\n                    columns === 4 && 'grid-cols-4',\r\n                  )}\r\n                >\r\n                  {visibleIcons.map((name) => {\r\n                    const isSelected = name === draft;\r\n\r\n                    return (\r\n                      <button\r\n                        key={name}\r\n                        type=\"button\"\r\n                        onMouseEnter={() => onHoverIcon(name)}\r\n                        onMouseLeave={onUnhoverIcon}\r\n                        onClick={() => {\r\n                          if (scrollRef.current) {\r\n                            scrollPositionRef.current = scrollRef.current.scrollTop;\r\n                          }\r\n                          setValue(name);\r\n                        }}\r\n                        className={cn(\r\n                          'h-10 rounded-md border border-[var(--border)] px-2 text-left text-sm flex items-center gap-2 transition-colors',\r\n                          'hover:bg-[var(--accent)]',\r\n                          isSelected && 'ring-2 ring-[var(--ring)] ring-offset-2 ring-offset-[var(--background)]',\r\n                        )}\r\n                      >\r\n                        <span className=\"inline-flex h-6 w-6 items-center justify-center rounded bg-[var(--muted)] shrink-0\">\r\n                          <DynamicIcon\r\n                            key={name}\r\n                            name={name}\r\n                            fallback={FolderKanban}\r\n                            className=\"h-4 w-4 text-[var(--foreground)]\"\r\n                          />\r\n                        </span>\r\n                        <span className=\"truncate flex-1\">{formatProjectIconLabel(name)}</span>\r\n                      </button>\r\n                    );\r\n                  })}\r\n                </div>\r\n              </div>\r\n            )}\r\n          </div>\r\n        </div>\r\n      </div>\r\n\r\n      <DialogFooter>\r\n        <Button\r\n          type=\"button\"\r\n          variant=\"outline\"\r\n          onClick={() => setOpen(false)}\r\n        >\r\n          Cancel\r\n        </Button>\r\n        <Button\r\n          type=\"button\"\r\n          onClick={() => {\r\n            setValue(draft);\r\n            setOpen(false);\r\n          }}\r\n        >\r\n          Select\r\n        </Button>\r\n      </DialogFooter>\r\n    </DialogContent>\r\n  );\r\n}\r\n\r\nexport interface IconPickerPreviewProps extends React.ComponentProps<'div'> {\r\n  size?: number;\r\n}\r\n\r\nexport function IconPickerPreview({ className, size = 24, ...props }: IconPickerPreviewProps) {\r\n  const { value, color } = useIconPicker();\r\n  const iconName = React.useMemo(() => normalizeProjectIconName(value) ?? 'folder-kanban', [value]);\r\n\r\n  return (\r\n    <div\r\n      className={cn('inline-flex items-center justify-center', className)}\r\n      {...props}\r\n    >\r\n      <DynamicIcon\r\n        name={iconName}\r\n        fallback={FolderKanban}\r\n        width={size}\r\n        height={size}\r\n        className={cn(color ? 'text-white' : 'text-[var(--foreground)]')}\r\n      />\r\n    </div>\r\n  );\r\n}\r\n",
      "type": "registry:ui"
    }
  ],
  "type": "registry:ui"
}